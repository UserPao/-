## 进程调度算法

**FIFO或First Come, First Served (FCFS)先来先服务**

- 调度的顺序就是任务到达就绪队列的顺序
- 公平、简单(FIFO队列)、非抢占、不适合交互式
- 未考虑任务特性，平均等待时间可以缩短

**Shortest Job First (SJF)**

- 最短的作业(CPU区间长度最小)最先调度
- SJF可以保证最小的平均等待时间

**优先权调度**

- 每个任务关联一个优先权，调度优先权最高的任务
- 注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象

**Round-Robin(RR)轮转调度算法**

- 设置一个时间片，按时间片来轮转调度（“轮叫”算法）
- 优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多
- 时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS

**多级队列调度**

- 按照一定的规则建立多个进程队列
- 不同的队列有固定的优先级（高优先级有抢占权）
- 不同的队列可以给不同的时间片和采用不同的调度方法
- 存在问题1：没法区分I/O bound和CPU bound
- 存在问题2：也存在一定程度的“饥饿”现象

**多级反馈队列**

- 在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务
- 可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”
- 最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等

## 页面置换算法

操作系统将内存按照页面进行管理，在需要的时候才把进程对应的部门调入内存。当产生缺页中断的时候，需要选择一个页面写入。如果要换出的页面在内存中被修改，变成了“脏”页面，就需要先写入磁盘。页面置换算法，就是选出来一个最合适的页面，使得置换的效率最高，

- 最优页面置换算法
- 梦想
- 先进先出
- 最近最少使用LRU

## 虚拟内存

计算机内存管理的一种技术，**使得应用程序认为它拥有一段连续可用的内存，而实际上，它通常被分割成多个物理内存碎片，还有一部分暂时的存储在外部磁盘存储器上，在需要的时候进行数据交换**

每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，虚拟的意思就是，其实这个地址空间是不存在的，仅仅是每个进程“认为”自己拥有4G的内存，而实际上，它用了多少空间，操作系统就在磁盘上划出多少空间给它，等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行数据拷贝

当一个进程试图访问虚拟地址空间中的某个数据时，会经历下面两种情况的过程：

1. CPU想访问某个虚拟内存地址，**找到进程对应的页表中的条目**，判断有效位， 如果有效位为1，说明在页表条目中的物理内存地址不为空，根据物理内存地址，访问物理内存中的内容，返回
2. CPU想访问某个虚拟内存地址，找到进程对应的页表中的条目，判断有效位，如果有效位为0，但页表条目中还有地址，这个地址是磁盘空间的地址，这时触发缺页异常，系统把物理内存中的一些数据拷贝到磁盘上，腾出所需的空间，并且更新页表。此时重新执行访问之前虚拟内存的指令，就会发现变成了情况1.

具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统，其逻辑容量由内存和外存之和决定。

与传统存储器比较，虚拟存储器有以下特征：

- 多次性：指无需在作业运行时一次性的将全部装入内存，允许被分成多次调入内存运行
- 对换性：是指无需再作业运行时一致常驻内存，而是允许在作业的运行过程中，进行换进和换出
- 虚拟性：指从逻辑上扩充内存的容量，是用户所看到的内存容量，远远大于实际的内存容量

虚拟内存的实现由以下两种方式

- 请求分页存储管理
- 请求分段存储管理

## 逻辑地址

**为什么要有逻辑地址**

逻辑地址是指程序自身看到的内存空间，是抽象的地址，逻辑地址要映射到物理地址才能完成对内存的操作。

因为**程序是写死的，操作的地址是固定的，硬件可用的地址是变化的，所以为了进程的安全必须做逻辑地址**

**映射关系**

1. 固定偏移量

   <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20200810200307566.png" alt="image-20200810200307566" style="zoom:25%;" />

   缺点是程序使用的内存是无法预估的。会产生内碎片。

2. **分页**

   将内存的空间，包括逻辑内存和物理内存都进行切分成固定大小的页，逻辑内存中叫做页，物理内存中叫做帧

   有个**页表**来记录页到帧的映射关系。**每个进行维护自己的页表**

   有的内存是不够的，会把数据放在磁盘中，也就是说**页表中可能记录的是页到磁盘号的映射**

   **例子**

   ​	机器是32位系统，256M的内存，页大小是4KB

   ​	程序是32位的程序

   ​	4K = 12bit因此

   ​	逻辑地址32bit = 20bit页号+12bit偏移量

   ​	物理地址28bit【256M】=16bit帧号+12bit偏移量

   ​	对逻辑地址为：0x000011a3 拆分为页号为00001页内偏移量为1a3

   ​	通过查询**页表**找到页号对应的帧号为00f3，则对应的物理地址为00f31a3

   ​	**假如对应的帧号是磁盘，就会发生缺页中断**，用户态切换到内核态，并将数据从磁盘拿到内存中，更新页表中的值

   **时间优化**

   将最常访问的页表项存在访问速度更快的硬件中，一般是MMU（内存管理单元，放在cpu中），这个小表叫做**TLB**，称为快表。

   **空间优化**

   使用多级页表

3. **分段**

   程序内部的内存管理